"""
Think Bayes
This notebook presents example code and exercise solutions for Think Bayes.
Copyright 2018 Allen B. Downey
MIT License: https://opensource.org/licenses/MIT
"""

import pytest
import numpy as np
import thinkbayes
from thinkbayes import Pmf, Suite
from thinkbayes import thinkplot


class Dungeons(Suite):
    """
    The Dungeons and Dragons club
    Suppose there are 10 people in my *Dungeons and Dragons* club;
    on any game day, each of them has a 70% chance of showing up.
    Each player has one character and each character has 6 attributes,
    each of which is generated by rolling and adding up 3 6-sided dice.
    At the beginning of the game, I ask whose character has the lowest attribute.
    The wizard says, "My constitution is 5; does anyone have a lower attribute?", and no one does.
    The warrior says "My strength is 16; does anyone have a higher attribute?", and no one does.
    How many characters are in the party?

    The prior
    There are three ways to compute the prior distribution:
    * Simulation
    * Convolution
    * Analytic distribution

    Here's a class that implements this likelihood function.

    """

    def __init__(self, obj=None, label=None):
        super().__init__(obj, label)

        self.flips = [self.flip(0.7) for _ in range(10)]

        d6 = Pmf([1, 2, 3, 4, 5, 6])
        thrice = sum([d6] * 3)
        cdf_thrice = thrice.MakeCdf()
        self.like_min = {}
        self.like_max = {}
        for n in range(2, 11):
            cdf_min = self.compute_cdf_min(cdf_thrice, n * 6)
            self.like_min[n] = cdf_min.MakePmf()
            cdf_max = cdf_thrice.Max(n * 6)
            self.like_max[n] = cdf_max.MakePmf()
            print(self.like_min[n][5], self.like_max[n][16])

    def Likelihood(self, data, hypo):
        """Probability of the data given the hypothesis.

        data: lowest attribute, highest attribute, boolean
              (whether the same person has both)
        hypo: number of players

        returns: probability
        """
        lowest, highest, same = data
        n = hypo

        p = self.prob_same(n)
        like = p if same else 1 - p

        like *= self.like_min[n][lowest]
        like *= self.like_max[n][highest]

        return like

    @staticmethod
    def prob_same(n):
        return 5 / (6 * n - 1)

    @staticmethod
    def compute_cdf_min(cdf, k):
        """CDF of the min of k samples from cdf.

        cdf: Cdf object
        k: number of samples

        returns: new Cdf object
        """
        cdf_min = cdf.Copy()
        cdf_min.ps = 1 - (1 - cdf_min.ps) ** k
        return cdf_min

    @staticmethod
    def flip(p):
        """
        First, simulation.  Here's a function that flips a coin with probability `p`:
        :param p:
        :return:
        """
        return np.random.random() < p

    def game_day(self, n, p):
        """
        Let's encapsulate that in a function that simulates a game day.
        """
        flips = [self.flip(p) for _ in range(n)]
        return sum(flips)


def test_game_day():
    """
    # If we run that function many times, we get a sample from the distribution of the number of players.
    """
    dungeon_instance = Dungeons()
    dungeon_instance.game_day(10, 0.7)
    sample = [dungeon_instance.game_day(10, 0.7) for _ in range(1000)]
    pmf_sample = Pmf(sample)
    thinkplot.Hist(pmf_sample)


def coin(p):
    """
    The second method is convolution.
    Instead of flipping a coin,
    we can create a `Pmf` object that represents the distribution of outcomes from a single flip.
    :param p:
    :return:
    """
    return Pmf({1: p, 0: 1 - p})


def test_conv():
    """
    Here's what it looks like.
    """
    player = coin(0.7)
    player.Print()


def test_add():
    """
    If we have two players, there are three possible outcomes:
    """
    player = coin(0.7)
    (player + player).Print()


@pytest.fixture(name="prior")
def prior_fixture():
    """
    If we have 10 players, we can get the prior distribution like this:
    """
    player = coin(0.7)
    prior = sum([player] * 10)
    prior.Print()
    return prior


def test_compare():
    """
    Now we can compare the results of simulation and convolution:
    """
    dungeon_instance = Dungeons()
    dungeon_instance.game_day(10, 0.7)
    sample = [dungeon_instance.game_day(10, 0.7) for _ in range(1000)]
    pmf_sample = Pmf(sample)

    thinkplot.Hist(pmf_sample, color="C0")

    player = coin(0.7)
    prior = sum([player] * 10)

    thinkplot.Pmf(prior, color="C1")
    thinkplot.decorate(xlabel="Number of players", ylabel="PMF")


def test_analytic(prior):
    r"""
    Finally, we can use an analytic distribution.
    The distribution we just computed is the
    [binomial distribution](https://en.wikipedia.org/wiki/Binomial_distribution),
    which has the following PMF:
    $ PMF(k; n, p) = P(k ~|~ n, p) = {n \choose k}\,p^{k}(1-p)^{n-k}$
    We could evaluate the right hand side in Python, or use `MakeBinomialPmf`:
    And we can confirm that the analytic result matches what we computed by convolution.
    """

    binomial = thinkbayes.MakeBinomialPmf(10, 0.7)
    thinkplot.Pmf(prior, color="C1")
    thinkplot.Pmf(binomial, color="C2", linestyle="dotted")
    thinkplot.decorate(xlabel="Number of players", ylabel="PMF")


def test_eliminate(prior):
    """
    Since two players spoke, we can eliminate the possibility of 0 or 1 players:
    """
    thinkplot.Pmf(prior, color="gray")
    del prior[0]
    del prior[1]
    prior.Normalize()
    thinkplot.Pmf(prior, color="C1")
    thinkplot.decorate(xlabel="Number of players", ylabel="PMF")


@pytest.fixture(name="thrice")
def thrice_fixture():
    """
    Likelihood
    There are three components of the likelihood function:
    * The probability that the highest attribute is 16.
    * The probability that the lowest attribute is 5.
    * The probability that the lowest and highest attributes are held by different players.
    To compute the first component,
    we have to compute the distribution of the maximum of $6n$ attributes, where $n$ is the number of players.
    Here is the distribution for a single die and the sum of three dice.
    """
    d6 = Pmf([1, 2, 3, 4, 5, 6])
    d6.Print()
    thrice = sum([d6] * 3)
    thinkplot.Pdf(thrice)
    thinkplot.decorate(xlabel="Attribute", ylabel="PMF")
    return thrice


@pytest.fixture(name="cdf_thrice")
def cdf_thrice_fixture(thrice):
    return thrice.MakeCdf()


@pytest.fixture(name="like_min")
def like_min_fixture(cdf_thrice):
    dungeon_instance = Dungeons()
    like_min = {}
    like_max = {}

    for n in range(2, 11):
        cdf_min = dungeon_instance.compute_cdf_min(cdf_thrice, n * 6)
        like_min[n] = cdf_min.MakePmf()
        cdf_max = cdf_thrice.Max(n * 6)
        like_max[n] = cdf_max.MakePmf()
        print(like_min[n][5], like_max[n][16])
    return like_min


@pytest.fixture(name="like_max")
def like_max_fixture(cdf_thrice):
    like_min = {}
    like_max = {}
    dungeon_instance = Dungeons()

    for n in range(2, 11):
        cdf_min = dungeon_instance.compute_cdf_min(cdf_thrice, n * 6)
        like_min[n] = cdf_min.MakePmf()
        cdf_max = cdf_thrice.Max(n * 6)
        like_max[n] = cdf_max.MakePmf()
        print(like_min[n][5], like_max[n][16])
    return like_max


def test_cdf_max(cdf_thrice):
    """
    Here's the CDF for the sum of three dice.
    The `Max` method raises the CDF to a power.  So here's the CDF for the maximum of six attributes.
    """

    thinkplot.Cdf(cdf_thrice)
    thinkplot.decorate(xlabel="Attribute", ylabel="CDF")
    cdf_max_6 = cdf_thrice.Max(6)
    thinkplot.Cdf(cdf_max_6)
    thinkplot.decorate(
        xlabel="Attribute", ylabel="CDF", title="Maximum of 6 attributes"
    )


def test_n_cdf_max(cdf_thrice):
    """
    If there are `n` players, there are `6*n` attributes.
    Here are the distributions for the maximum attribute of `n` players, for a few values of `n`.
    """

    for n in range(2, 10, 2):
        cdf_max = cdf_thrice.Max(n * 6)
        thinkplot.Cdf(cdf_max, label="n=%s" % n)

    thinkplot.decorate(
        xlabel="Attribute", ylabel="CDF", title="Maximum of 6*n attributes"
    )


def test_n_sim(cdf_thrice):
    """
    To check that, I'll compute the CDF for 7 players, and estimate it by simulation.
    """

    n = 7
    cdf = cdf_thrice.Max(n * 6)
    thinkplot.Cdf(cdf, label="n=%s" % n)
    sample_max = [max(cdf_thrice.Sample(42)) for _ in range(1000)]
    thinkplot.Cdf(thinkbayes.Cdf(sample_max), label="sample")
    thinkplot.decorate(
        xlabel="Attribute", ylabel="CDF", title="Maximum of 6*n attributes"
    )


def test_compute_cdf_min(cdf_thrice):
    """
    Now, to compute the minimum, I have to write my own function, because `Cdf` doesn't provide a `Min` function.
    Now we can compute the CDF of the minimum attribute for `n` players, for several values of `n`.
    """
    dungeon_instance = Dungeons()
    for n in range(2, 10, 2):
        cdf_min = dungeon_instance.compute_cdf_min(cdf_thrice, n * 6)
        thinkplot.Cdf(cdf_min, label="n=%s" % n)

    thinkplot.decorate(
        xlabel="Attribute", ylabel="CDF", title="Minimum of 6*n attributes"
    )


def test_compute_cdf_min_sim(cdf_thrice):
    """
    And again we can check it by comparing to simulation results.
    """
    dungeon_instance = Dungeons()
    n = 7
    cdf = dungeon_instance.compute_cdf_min(cdf_thrice, n * 6)
    thinkplot.Cdf(cdf, label="n=%s" % n)

    sample_min = [min(cdf_thrice.Sample(42)) for _ in range(1000)]
    thinkplot.Cdf(thinkbayes.Cdf(sample_min), label="sample")

    thinkplot.decorate(
        xlabel="Attribute", ylabel="CDF", title="Minimum of 6*n attributes"
    )


def test_precompute(cdf_thrice, like_min, like_max):
    """
    For efficiency and conciseness,
    it is helpful to precompute the distributions for the relevant values of `n`, and store them in dictionaries.

    The output shows that the particular data we saw is symmetric:
    the chance that 16 is the maximum is the same as the chance that 5 is the minimum.
    """
    dungeon_instance = Dungeons()
    for n in range(2, 11):
        cdf_min = dungeon_instance.compute_cdf_min(cdf_thrice, n * 6)
        like_min[n] = cdf_min.MakePmf()
        cdf_max = cdf_thrice.Max(n * 6)
        like_max[n] = cdf_max.MakePmf()
        print(like_min[n][5], like_max[n][16])


def test_min_max_same(d6):
    """
    Finally, we need the probability that the minimum and maximum are held by the same person.
    If there are `n` players, there are `6*n` attributes.
    Let's call the player with the highest attribute Max.
    What is the chance that Max also has the lowest attribute?
    Well Max has 5 more attributes, out of a total of `6*n-1` remaining attributes.
    So here's `prob_same` as a function of `n`.
    """
    dungeon_instance = Dungeons()

    dungeon_instance.game_day(10, 0.7)

    player = coin(0.7)

    prior = sum([player] * 10)

    del prior[0]
    del prior[1]
    prior.Normalize()

    suite = Dungeons(prior)

    suite.Update((5, 16, False))

    ci = suite.CredibleInterval()
    print(ci)
    result = sum(suite[n] for n in range(ci[0], ci[1] + 1))
    assert result == pytest.approx(0.9, abs=0.1)
